/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f1xx.h"

#define GPIO_PIN_5                 ((uint16_t)0x0020)  /* Pin 5 selected    */
#define GPIO_PIN_6                 ((uint16_t)0x0040)  /* Pin 6 selected    */
#define GPIO_PIN_7                 ((uint16_t)0x0080)  /* Pin 7 selected    */
#define Ativado 1
#define Desativado 0

/*
 * SysTick_Handler interrupt handler
 */
int SysTick_TASK = 0;
char Unlock_Tick = Desativado;
void SysTick_Handler(void)
{
	// Do stuff
	SysTick_TASK++;
	Unlock_Tick = Ativado;
}

int main(void)
{
	// Set Bit 4 to enable GPIOC clock
	RCC->APB2ENR |= (1 << 4) | RCC_APB2ENR_IOPAEN;

	// Make GPIOE Pin13 output
	GPIOC->CRH &= 0xFF0FFFFF;
	GPIOC->CRH |= 0x00200000;

	// Make GPIOB Pin5,6,7 output
    // Configuração de PA5, PA6, PA7 como saída push-pull
    GPIOA->CRL &= ~(GPIO_CRL_MODE5 | GPIO_CRL_CNF5 | GPIO_CRL_MODE6 | GPIO_CRL_CNF6 | GPIO_CRL_MODE7 | GPIO_CRL_CNF7);
    GPIOA->CRL |= (GPIO_CRL_MODE5_1 | GPIO_CRL_MODE6_1 | GPIO_CRL_MODE7_1);  // Output de até 2 MHz

	// Reset GPIOC Pin13
	GPIOC->ODR &= ~(1 << 13);


	// Reset GPIOA Pin5,6,7
	GPIOB->ODR &= ~((1 << 5)|(1 << 6)|(1 << 7));

	/*System Tick Configuration
	 * Initializes the System Timer and its interrupt, and starts the System Tick Timer.
     * Counter is in free running mode to generate periodic interrupts.
	 */
	uint32_t ticks = 1000000; //ticks  Number of ticks between two interrupts, should be less than 0xFFFFFFUL = 16777216  (24bits)
	if ((ticks - 1UL) <= 0xFFFFFFUL)
	{
		 /* set reload register */
		SysTick->LOAD  = (uint32_t)(ticks - 1UL);

		/* set Priority for Systick Interrupt */
		//NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL);

		SysTick->VAL   = 0UL;			/* Load the SysTick Counter Value */

		SysTick->CTRL  = (0 << 2) |		/* 0 -> SysTick_Clock = AHB/8 */
						 (1 << 1) |	 	/* Enable SysTick IRQ and SysTick Timer */
						 (1 << 0);
	}
	while(1)
	{
	    if(Unlock_Tick) {
	        Unlock_Tick = Desativado;
	        GPIOC->ODR ^= (1 << 13);

	        // Reset all pins (PA5, PA6, PA7)
	        GPIOA->ODR &= ~(GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7);

	        switch(SysTick_TASK) {
	            case 1: // vermelho
	                GPIOA->ODR |= GPIO_PIN_5;
	                break;
	            case 2: // verde
	                GPIOA->ODR |= GPIO_PIN_6;
	                break;
	            case 3: // azul
	                GPIOA->ODR |= GPIO_PIN_7;
	                break;
	            case 4: // amarelo
	                GPIOA->ODR |= GPIO_PIN_5 | GPIO_PIN_6;
	                break;
	            case 5: // ciano
	                GPIOA->ODR |= GPIO_PIN_6 | GPIO_PIN_7;
	                break;
	            case 6: // roxo
	                GPIOA->ODR |= GPIO_PIN_5 | GPIO_PIN_7;
	                break;
	            case 7: // branco
	                GPIOA->ODR |= GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
	                break;
	            default: // Reseta as variáveis
	                SysTick_TASK = 0;
	                break;
	        }
	    }
	}

}
